import sys, os
import argparse
from termcolor import cprint
from google.protobuf.text_format import Merge
this_dir = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, os.path.join(this_dir, '../caffe-proto/parse-proto/'))
import caffe_pb2

linker_attr = ('#pragma DATA_SECTION({var_name}, ".shared_ocm")',)

c_header = ('/*This file is automatically generated. Do not modify.\n'
    'This file contains matrix dimensions for different GEMM based convolution layers\n'
    '*/\n')
h_header = ('/*This file is automatically generated. Do not modify.\n'
    '*/\n')

def parse_args():
    """Argument parser for this tool
    """
    parser = argparse.ArgumentParser(description='Generate matrix dimensions for GEMM based Convolution layer')
    parser.add_argument('--model', dest='model_file', help='Network definition file in .prototxt format.')
    parser.add_argument('--prefix', dest='prefix', nargs='?', default='custom_net', type=str, help='Prefix to be used for all naming purposes.')

    # parse command line args
    if(len(sys.argv) < 2):
        parser.print_help()
        sys.exit()
    args = parser.parse_args()
    return args

def generate_gemm_params(model_file):

    net = caffe_pb2.NetParameter()

    Merge((open(model_file, 'r').read()), net)
    gemm_dim = []

    input_dim = [0, 0, 0]
    for lyr in net.layer:
        print(lyr.type)
        if(lyr.type == "Input"):
            input_dim =[ lyr.input_param.shape[0].dim[1], lyr.input_param.shape[0].dim[2], lyr.input_param.shape[0].dim[3]]
            print input_dim
        elif(lyr.type == "Convolution"):
            print input_dim
            no_outputs = lyr.convolution_param.num_output
            ker_h = lyr.convolution_param.kernel_h
            ker_w = lyr.convolution_param.kernel_w
            ker = lyr.convolution_param.kernel_size[0]
            pad_h = lyr.convolution_param.pad_h
            pad_w = lyr.convolution_param.pad_w
            if(lyr.convolution_param.pad):
                pad = lyr.convolution_param.pad[0]
            else:
                pad = []
            stride_h = lyr.convolution_param.stride_h
            stride_w = lyr.convolution_param.stride_w
            if(lyr.convolution_param.stride):
                stride = lyr.convolution_param.stride[0]
            else:
                stride = 0

            if(not pad):
                pad = 0
            if(not stride):
                stride = 1

            ker_h = ker if (ker_h == 0) else ker_h
            ker_w = ker if (ker_w == 0) else ker_w
            pad_h = pad if (pad_h == 0) else pad_h
            pad_w = pad if (pad_w == 0) else pad_w
            stride_h = stride if(stride_h == 0) else stride_h            
            stride_w = stride if(stride_w == 0) else stride_w

            out_h = int((input_dim[1] + 2*pad_h - ker_h + 1 + stride_h - 1)/stride_h)
            out_w = int((input_dim[2] + 2*pad_w - ker_w + 1 + stride_w - 1)/stride_w)
            gemm_dim.append([no_outputs, input_dim[0] * ker_h * ker_w, out_h * out_w])
            input_dim = [no_outputs, out_h, out_w]

            print input_dim
        elif(lyr.type == "Pooling"):
            print input_dim
            ker_h = lyr.pooling_param.kernel_h
            ker_w = lyr.pooling_param.kernel_w
            ker = lyr.pooling_param.kernel_size
            pad_h = lyr.pooling_param.pad_h
            pad_w = lyr.pooling_param.pad_w
            pad = lyr.pooling_param.pad
            stride_h = lyr.pooling_param.stride_h
            stride_w = lyr.pooling_param.stride_w
            stride = lyr.pooling_param.stride

            if(not pad):
                pad = 0
            if(not stride):
                stride = 1
            ker_h = ker if (ker_h == 0) else ker_h
            ker_w = ker if (ker_w == 0) else ker_w
            pad_h = pad if (pad_h == 0) else pad_h
            pad_w = pad if (pad_w == 0) else pad_w
            stride_h = stride if(stride_h == 0) else stride_h            
            stride_w = stride if(stride_w == 0) else stride_w
            
            out_h = int((input_dim[1] + 2*pad_h - ker_h + 1 + stride_h - 1)/stride_h)
            out_w = int((input_dim[2] + 2*pad_w - ker_w + 1 + stride_w - 1)/stride_w)
            input_dim = [no_outputs, out_h, out_w]
            print input_dim

    return gemm_dim

def write_gemm_params(gemm_dims, prefix):
    
    gemm_cfile_name = prefix + '_conv_gemm_params.c'
    gemm_hfile_name = prefix + '_conv_gemm_params.h'
    A_height_name = prefix + '_A_height'
    A_width_name = prefix + '_A_width'
    B_width_name = prefix + '_B_width'
    def_no_conv_layers = 'NO_GEMMS'

    header_protect = '_' + prefix.upper() + '_CONV_GEMM_PARAMS_H_'

    h_cfile = open(gemm_cfile_name, 'w')
    h_hfile = open(gemm_hfile_name, 'w')

    # dump header documentation
    h_cfile.write(c_header)
    h_hfile.write(h_header)
    h_hfile.write('#ifndef ' + header_protect + '\n' + '#define ' + header_protect + '\n'
        '#include "stdint.h"\n\n')

    h_hfile.write('#define {:s}\t({:d})\n\n'.format(def_no_conv_layers, len(gemm_dims)))

    h_hfile.write('extern const uint32_t {:s}[{:s}];\n\n'.format(A_height_name, def_no_conv_layers))
    h_hfile.write('extern const uint32_t {:s}[{:s}];\n\n'.format(A_width_name, def_no_conv_layers))
    h_hfile.write('extern const uint32_t {:s}[{:s}];\n\n'.format(B_width_name, def_no_conv_layers))

    h_cfile.write('#include "{:s}"\n\n'.format(gemm_hfile_name))

    # include linker attributes for this array if any
    for attr in linker_attr:
        h_cfile.write(attr.format(var_name=A_height_name) + '\n')

    h_cfile.write('const uint32_t {:s}[{:s}] = '.format(A_height_name, def_no_conv_layers) + '{\n')
    for i, e in enumerate(gemm_dims):
        if(i < len(gemm_dims) - 1):
            h_cfile.write('{:d}, '.format(e[0]))
        else:
            h_cfile.write('{:d}'.format(e[0]))
    h_cfile.write('};\n\n')

    h_cfile.write('const uint32_t {:s}[{:s}] = '.format(A_width_name, def_no_conv_layers) + '{\n')
    for i, e in enumerate(gemm_dims):
        if(i < len(gemm_dims) - 1):
            h_cfile.write('{:d}, '.format(e[1]))
        else:
            h_cfile.write('{:d}'.format(e[1]))
    h_cfile.write('};\n\n')
    h_cfile.write('const uint32_t {:s}[{:s}] = '.format(B_width_name, def_no_conv_layers) + '{\n')
    for i, e in enumerate(gemm_dims):
        if(i < len(gemm_dims) - 1):
            h_cfile.write('{:d}, '.format(e[2]))
        else:
            h_cfile.write('{:d}'.format(e[2]))
    h_cfile.write('};\n\n')

    h_hfile.write('#endif //' + header_protect + '\n')
    h_cfile.close()
    h_hfile.close()
    cprint('Created {:s} containing matrix dimensions for GEMM based implementation of all convolution layers present in the network'.format(gemm_cfile_name,), 'green')
    cprint('Created {:s} containing the array declaration and constant macro definition'.format(gemm_hfile_name,), 'green')
        
if __name__ == '__main__':

    # parse the arguments
    args = parse_args()

    gemm_dims = generate_gemm_params(args.model_file)
    print gemm_dims
    print args.prefix
    write_gemm_params(gemm_dims, args.prefix.lower())

